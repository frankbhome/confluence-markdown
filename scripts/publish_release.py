#!/usr/bin/env python3
# Copyright (c) 2025 Francis Bain
# SPDX-License-Identifier: Apache-2.0

"""Confluence Release Notes Publisher.

This script automatically publishes release notes to Confluence
when a new GitHub release is created.
"""

import json
import re
import sys
from typing import TYPE_CHECKING, Any, Optional

import requests
from decouple import config  # type: ignore
from requests.adapters import HTTPAdapter

if TYPE_CHECKING:
    from urllib3.util.retry import Retry
else:
    try:
        from urllib3.util.retry import Retry
    except ImportError:
        from requests.packages.urllib3.util.retry import Retry  # type: ignore


class ConfluencePublisher:
    """Publishes release notes to Confluence."""

    def __init__(self) -> None:
        """
        Initialize the ConfluencePublisher by loading required configuration from environment.

        Reads the following environment variables via decouple.config:
        - CONFLUENCE_URL, CONFLUENCE_USER, CONFLUENCE_TOKEN, CONFLUENCE_SPACE (required)
        - CONFLUENCE_PARENT_PAGE, GITHUB_REPOSITORY (optional)

        Raises:
            ValueError: If any of the required Confluence settings (URL, user, token, space)
                are missing.
        """
        self.confluence_url = str(config("CONFLUENCE_URL", default=""))  # type: ignore
        self.confluence_user = str(config("CONFLUENCE_USER", default=""))  # type: ignore
        self.confluence_token = str(config("CONFLUENCE_TOKEN", default=""))  # type: ignore
        self.confluence_space = str(config("CONFLUENCE_SPACE", default=""))  # type: ignore
        self.confluence_parent_page = str(config("CONFLUENCE_PARENT_PAGE", default=""))  # type: ignore
        self.github_repository = str(config("GITHUB_REPOSITORY", default=""))  # type: ignore

        if not all(
            [
                self.confluence_url,
                self.confluence_user,
                self.confluence_token,
                self.confluence_space,
            ]
        ):
            raise ValueError(
                "Missing required Confluence configuration "
                "(URL, user, token, and space are required)"
            )

    def get_auth_headers(self) -> dict[str, str]:
        """
        Return HTTP headers configured for Confluence REST API requests.

        Returns:
            Dict[str, str]: Headers including an HTTP Basic `Authorization` header (built from the configured Confluence user and token) and JSON `Content-Type`/`Accept` headers.
        """
        import base64

        auth_string = f"{self.confluence_user}:{self.confluence_token}"
        auth_bytes = auth_string.encode("ascii")
        auth_b64 = base64.b64encode(auth_bytes).decode("ascii")

        return {
            "Authorization": f"Basic {auth_b64}",
            "Content-Type": "application/json",
            "Accept": "application/json",
        }

    def get_session(self) -> requests.Session:
        """
        Create a requests session with retry logic and timeout configuration.

        Returns:
            requests.Session: Session configured with retry strategy for resilient HTTP requests.
        """
        session = requests.Session()
        retry: Retry = Retry(
            total=3,
            backoff_factor=1,
            status_forcelist=[500, 502, 503, 504],
            raise_on_status=False,
        )
        adapter = HTTPAdapter(max_retries=retry)
        session.mount("https://", adapter)
        session.mount("http://", adapter)
        return session

    def create_confluence_content(self, title: str, version: str, release_notes: str) -> str:
        """
        Build Confluence storage-format HTML for a release page including header, release notes, installation snippet, and metadata.

        The generated content includes:
        - An H1 title ("Release {version}") and the current date.
        - An optional GitHub tag link when the publisher was configured with a GitHub repository.
        - A "Release Notes" section where the provided Markdown is converted to Confluence storage format.
        - An "Installation" code macro containing `pip install confluence-markdown==<version>`; the install command strips a leading 'v' from the version (e.g., "v1.2.3" -> "1.2.3").
        - A small note stating the page was autogenerated from the GitHub release.

        Parameters:
            title: Page title (used for context; the function composes its own H1 using `version`).
            version: Release version string placed in the title and used in the installation command.
            release_notes: Release notes in Markdown; converted to Confluence storage format.

        Returns:
            A string containing the page body in Confluence storage format.
        """
        # Convert markdown to Confluence storage format
        github_url = (
            f"https://github.com/{self.github_repository}/releases/tag/{version}"
            if self.github_repository
            else ""
        )
        confluence_content = f"""
<h1>Release {version}</h1>
<p><strong>Release Date:</strong> {self._get_current_date()}</p>
{f'<p><strong>GitHub Tag:</strong> <a href="{github_url}">{version}</a></p>' if github_url else ""}

<h2>Release Notes</h2>
{self._convert_markdown_to_confluence(release_notes)}

<h2>Installation</h2>
<ac:structured-macro ac:name="code" ac:schema-version="1">
<ac:parameter ac:name="language">bash</ac:parameter>
<ac:plain-text-body><![CDATA[
pip install confluence-markdown=={version.lstrip("v")}
]]></ac:plain-text-body>
</ac:structured-macro>

<p><em>This release note was automatically generated from GitHub release.</em></p>
"""
        return confluence_content.strip()

    def _convert_markdown_to_confluence(self, markdown: str) -> str:
        """
        Convert a subset of Markdown into Confluence storage-format HTML.

        Supports:
        - Fenced code blocks (```lang\ncode\n```) — preserved and replaced with Confluence
          code macro; language parameter is kept when present, otherwise "text".
        - Inline code using backticks -> <code>...</code>.
        - ATX headers (#, ##, ###) -> <h1>, <h2>, <h3>.
        - Unordered lists starting with "- " -> <ul><li>...</li></ul>.
        - Bold (**text**) -> <strong>, italic (*text*) -> <em>.
        - Markdown links [text](url) -> <a href="url">text</a>.
        - Simple paragraph wrapping for non-empty lines that are not already HTML or code placeholders.

        Code blocks are temporarily replaced with placeholders during processing to avoid accidental transformation,
        then restored as Confluence `<ac:structured-macro ac:name="code">` blocks containing the code inside CDATA.

        Parameters:
            markdown (str): Markdown source text to convert.

        Returns:
            str: Converted string in Confluence storage format.
        """
        import html

        # Store code blocks temporarily to protect them during processing
        code_blocks: list[str] = []

        def store_code_block(match: re.Match[str]) -> str:
            """
            Store a matched fenced code block and return a placeholder token.

            Parameters:
                match (re.Match[str]): A regex Match object representing a fenced code block. The entire matched text (match.group(0)) is appended to the module-level `code_blocks` list.

            Returns:
                str: A placeholder token of the form "__CODE_BLOCK_{n}__" where n is the index of the stored block in `code_blocks`.

            Side effects:
                Appends the matched code block text to the `code_blocks` list in the enclosing scope.
            """
            code_blocks.append(match.group(0))
            return f"__CODE_BLOCK_{len(code_blocks) - 1}__"

        # Extract and store fenced code blocks first (before HTML escaping)
        markdown = re.sub(
            r"```(\w+)?\n(.*?)\n```",
            store_code_block,
            markdown,
            flags=re.DOTALL,
        )

        # Escape HTML special characters to prevent XSS and format issues
        markdown = html.escape(markdown)

        # Convert inline code blocks (after escaping, since backticks are safe)
        markdown = re.sub(r"`([^`]+)`", r"<code>\1</code>", markdown)

        # Convert headers
        markdown = re.sub(r"^### (.*)", r"<h3>\1</h3>", markdown, flags=re.MULTILINE)
        markdown = re.sub(r"^## (.*)", r"<h2>\1</h2>", markdown, flags=re.MULTILINE)
        markdown = re.sub(r"^# (.*)", r"<h1>\1</h1>", markdown, flags=re.MULTILINE)

        # Convert lists
        markdown = re.sub(r"^- (.*)", r"<li>\1</li>", markdown, flags=re.MULTILINE)
        markdown = re.sub(r"(<li>.*</li>\n)+", r"<ul>\g<0></ul>", markdown, flags=re.DOTALL)

        # Convert bold
        markdown = re.sub(r"\*\*(.*?)\*\*", r"<strong>\1</strong>", markdown)

        # Convert italic
        markdown = re.sub(r"\*([^*]+)\*", r"<em>\1</em>", markdown)

        # Convert links
        markdown = re.sub(r"\[([^\]]+)\]\(([^)]+)\)", r'<a href="\2">\1</a>', markdown)

        # Convert paragraphs (but skip lines that are already HTML or empty)
        lines = markdown.split("\n")
        result: list[str] = []

        for line in lines:
            line = line.strip()

            # Only wrap in paragraphs if not already HTML and not a placeholder
            if line and not line.startswith("<") and not line.startswith("__CODE_BLOCK_"):
                line = f"<p>{line}</p>"
            result.append(line)

        # Restore code blocks with proper Confluence format
        final_result = "\n".join(result)
        for i, code_block in enumerate(code_blocks):
            # Parse the original code block to extract language and content
            match = re.match(r"```(\w+)?\n(.*?)\n```", code_block, re.DOTALL)
            if match:
                language = match.group(1) or "text"
                content = match.group(2)
                confluence_code = (
                    f'<ac:structured-macro ac:name="code" ac:schema-version="1">'
                    f'<ac:parameter ac:name="language">{language}</ac:parameter>'
                    f"<ac:plain-text-body><![CDATA[{content}]]></ac:plain-text-body>"
                    f"</ac:structured-macro>"
                )
                final_result = final_result.replace(f"__CODE_BLOCK_{i}__", confluence_code)

        return final_result

    def _get_current_date(self) -> str:
        """
        Return the current date formatted as "Month Day, Year" (e.g., "September 20, 2025").

        Returns:
            str: Current date in "Month Day, Year" format.
        """
        from datetime import datetime

        return datetime.now().strftime("%B %d, %Y")

    def find_parent_page_id(self) -> Optional[str]:
        """
        Return the Confluence page ID of the configured parent page, or None.

        If a parent page title was configured (CONFLUENCE_PARENT_PAGE) this method queries the Confluence REST API for a page with that title in the configured space and returns its id as a string when found. Returns None if no parent page is configured, if no matching page is found, or if the API request does not return a successful (200) response.
        """
        if not self.confluence_parent_page:
            return None

        url = f"{self.confluence_url}/rest/api/content"
        params = {
            "title": self.confluence_parent_page,
            "spaceKey": self.confluence_space,
            "expand": "version",
        }

        session = self.get_session()
        response = session.get(url, headers=self.get_auth_headers(), params=params, timeout=30)

        if response.status_code == 200:
            data = response.json()
            if data["results"]:
                return str(data["results"][0]["id"])

        return None

    def page_exists(self, version: str) -> bool:
        """
        Return whether a Confluence page for the given release version already exists.

        Constructs the page title as "Release {version} - confluence-markdown" and queries Confluence for a page with that title.

        Parameters:
            version (str): Release version string (e.g., "v1.0.0").

        Returns:
            bool: True if a page with the constructed title exists in Confluence, otherwise False.
        """
        title = f"Release {version} - confluence-markdown"
        existing_page = self._find_existing_page(title)
        return existing_page is not None

    def publish_release_notes(self, version: str, release_notes: str) -> bool:
        """Publish release notes to Confluence.

        Args:
            version: The release version (e.g., 'v1.0.0')
            release_notes: The release notes content

        Returns:
            True if successful, False otherwise
        """
        try:
            title = f"Release {version} - confluence-markdown"
            content = self.create_confluence_content(title, version, release_notes)

            # Check if page already exists
            existing_page = self._find_existing_page(title)

            if existing_page:
                # Update existing page
                return self._update_page(
                    existing_page["id"],
                    title,
                    content,
                    existing_page["version"]["number"],
                )
            else:
                # Create new page
                return self._create_page(title, content)

        except Exception as e:
            print(f"Error publishing to Confluence: {e}")
            return False

    def _find_existing_page(self, title: str) -> Optional[dict[str, Any]]:
        """
        Return the first Confluence page matching the given title in the configured space, or None if not found.

        Performs a GET to the Confluence REST API (/rest/api/content) with the title and spaceKey, requesting the `version` expansion. If the request is successful and results are present, returns the first page as a dict (including expanded `version` info). Returns None on non-200 responses or when no matching page exists.
        """
        url = f"{self.confluence_url}/rest/api/content"
        params = {
            "title": title,
            "spaceKey": self.confluence_space,
            "expand": "version",
        }

        session = self.get_session()
        response = session.get(url, headers=self.get_auth_headers(), params=params, timeout=30)

        if response.status_code == 200:
            data = response.json()
            if data["results"]:
                return dict(data["results"][0])

        return None

    def _create_page(self, title: str, content: str) -> bool:
        """
        Create a new Confluence page using the Confluence REST API.

        If a parent page is configured, the new page will be created as a child of that parent. Performs an HTTP POST to the Confluence content endpoint with the provided title and storage-format content, and prints a success or failure message.

        Returns:
            bool: True if the page was created (HTTP 200), False otherwise.
        """
        url = f"{self.confluence_url}/rest/api/content"

        page_data: dict[str, Any] = {
            "type": "page",
            "title": title,
            "space": {"key": self.confluence_space},
            "body": {"storage": {"value": content, "representation": "storage"}},
        }

        # Add parent page if specified
        parent_id = self.find_parent_page_id()
        if parent_id:
            page_data["ancestors"] = [{"id": parent_id}]  # type: ignore

        session = self.get_session()
        response = session.post(
            url, headers=self.get_auth_headers(), data=json.dumps(page_data), timeout=30
        )
        if response.status_code // 100 == 2:  # Accept any 2xx success code
            page_info = response.json()
            page_url = f"{self.confluence_url}/pages/viewpage.action?pageId={page_info['id']}"
            print(f"✅ Created Confluence page: {page_url}")
            return True
        else:
            print(f"❌ Failed to create page: {response.status_code} - {response.text}")
            return False

    def _update_page(self, page_id: str, title: str, content: str, current_version: int) -> bool:
        """
        Update an existing Confluence page by sending a PUT request that increments its version.

        Sends the updated title and body in Confluence storage representation and sets the page version to
        current_version + 1.

        Parameters:
            page_id: Confluence page id to update.
            title: New page title.
            content: Page body in Confluence storage format.
            current_version: Current numeric page version; the request will publish version current_version + 1.

        Returns:
            True if the HTTP update succeeded (status code 200), False otherwise.
        """
        url = f"{self.confluence_url}/rest/api/content/{page_id}"

        page_data: dict[str, Any] = {
            "version": {"number": current_version + 1},
            "title": title,
            "type": "page",
            "body": {"storage": {"value": content, "representation": "storage"}},
        }

        session = self.get_session()
        response = session.put(
            url, headers=self.get_auth_headers(), data=json.dumps(page_data), timeout=30
        )

        if response.status_code // 100 == 2:  # Accept any 2xx success code
            page_url = f"{self.confluence_url}/pages/viewpage.action?pageId={page_id}"
            print(f"✅ Updated Confluence page: {page_url}")
            return True
        else:
            print(f"❌ Failed to update page: {response.status_code} - {response.text}")
            return False


def main() -> None:
    """
    Entry point for CLI invocation that publishes release notes to Confluence.

    Expects two command-line arguments: a release version and a release-notes string
    (usage: publish_release.py <version> <release_notes>). Creates a ConfluencePublisher
    and attempts to create or update a release page; prints success or failure and
    exits with code 0 on success, 1 on any failure or incorrect usage.

    Behavior on errors:
    - If required configuration is missing, prints a configuration guidance message
      listing expected environment variables and exits with code 1.
    - On any other unexpected exception, prints the error and exits with code 1.
    """
    if len(sys.argv) != 3:
        print("Usage: publish_release.py <version> <release_notes>")
        print("Example: publish_release.py v1.0.0 'Initial release with awesome features'")
        sys.exit(1)

    version = sys.argv[1]
    release_notes = sys.argv[2]

    try:
        publisher = ConfluencePublisher()
        success = publisher.publish_release_notes(version, release_notes)

        if success:
            print(f"🎉 Successfully published release notes for {version} to Confluence!")
            sys.exit(0)
        else:
            print(f"❌ Failed to publish release notes for {version}")
            sys.exit(1)

    except ValueError as e:
        print(f"Configuration error: {e}")
        print("\nRequired environment variables:")
        print("- CONFLUENCE_URL: Your Confluence instance URL")
        print("- CONFLUENCE_USER: Your Confluence username/email")
        print("- CONFLUENCE_TOKEN: Your Confluence API token")
        print("- CONFLUENCE_SPACE: Confluence space key")
        print("- CONFLUENCE_PARENT_PAGE: Parent page title (optional)")
        sys.exit(1)
    except Exception as e:
        print(f"Unexpected error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
